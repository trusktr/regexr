{"version":3,"file":"global.js","mappings":"MACA,IAAIA,EAAsB,CCA1BA,EAAwB,CAACC,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXF,EAAoBI,EAAEF,EAAYC,KAASH,EAAoBI,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDH,EAAwB,CAACS,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFV,EAAyBC,IACH,oBAAXa,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeL,EAASa,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeL,EAAS,aAAc,CAAEe,OAAO,GAAO,G,wBCSvD,SAASC,EAAuCC,KAAgBC,GACtE,IAAIC,EAAS,GACTC,EAAQ,GAIZ,MAAMC,EAAc,IAAIJ,EAASK,KAC3BC,EAAOF,EAAYG,OAAS,EAC5BC,EAAaJ,EAAYE,GAAMG,MAAM,eAC3C,IAAIC,GAAiB,EAGjBN,EAAY,GAAGK,MAAM,OACnBD,GAEJJ,EAAY,GAAKA,EAAY,GAAGO,QAAQ,IAAK,IAC7CR,EAAQK,EAAW,GAAGG,QAAQ,IAAK,IACnCP,EAAYE,GAAQF,EAAYE,GAAMK,QAAQ,cAAe,KAJ7CD,GAAiB,EAO9BF,IAAYE,GAAiB,GAIlC,IAAK,IAAIE,EAAI,EAAGC,EAAIZ,EAAcM,OAAQK,EAAIC,EAAGD,GAAK,EAAG,CACxD,MAAME,EAAMb,EAAcW,GAC1BV,GAAUE,EAAYQ,GACtBV,GAAUY,aAAeC,OAASD,EAAIE,OAASC,OAAOH,E,CAMvD,GAFAZ,GAAUE,EAAYE,GAElBI,EACH,MAAM,IAAIQ,UACT,8FAA8FhB,MAIhG,OAAO,IAAIa,OAAOb,EAAQC,EAC3B,C,wEAEO,MAAMgB,EAAIpB,EAcJqB,EAAUC,GAAmBA,EAAOV,QAAQ,sBAAuB,QAEnEW,EAAIF,EAEJG,EAAU,O","sources":["webpack://regexr/webpack/bootstrap","webpack://regexr/webpack/runtime/define property getters","webpack://regexr/webpack/runtime/hasOwnProperty shorthand","webpack://regexr/webpack/runtime/make namespace object","webpack://regexr/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// TODO:\n//   - NOT operation like with regex-not package.\n//   - Caching like with the regex-cache package.\n\n/**\n * Template tag function to make composing regexes easier.\n *\n * @example\n *\n *   import {r} from 'regexr'\n *   const regex1 = r`/(this|that)*$/m`\n *   const regex2 = r`/something|other_${regex1}/g`\n *   console.log(regex2) // /something|other_(this|that)*$/g\n */\nexport function regexr<T extends TemplateStringsArray>(literals: T, ...substitutions: any[]) {\n\tlet result = ''\n\tlet flags = ''\n\n\t// We get the raw string that the user typed so that they don't have to\n\t// escape backslashes, etc, inside of the regex. Awesome!!\n\tconst rawLiterals = [...literals.raw]\n\tconst last = rawLiterals.length - 1\n\tconst flagsMatch = rawLiterals[last].match(/\\/[gimuy]*$/)\n\tlet flagMatchError = false\n\n\t// trim space before and after the regex.\n\tif (rawLiterals[0].match(/^\\//)) {\n\t\tif (!flagsMatch) flagMatchError = true\n\t\telse {\n\t\t\trawLiterals[0] = rawLiterals[0].replace('/', '')\n\t\t\tflags = flagsMatch[0].replace('/', '')\n\t\t\trawLiterals[last] = rawLiterals[last].replace(/\\/[gimuy]*$/, '')\n\t\t}\n\t} else {\n\t\tif (flagsMatch) flagMatchError = true\n\t}\n\n\t// run the loop only for the substitution count.\n\tfor (let i = 0, l = substitutions.length; i < l; i += 1) {\n\t\tconst sub = substitutions[i]\n\t\tresult += rawLiterals[i]\n\t\tresult += sub instanceof RegExp ? sub.source : String(sub)\n\t}\n\n\t// add the last literal\n\tresult += rawLiterals[last]\n\n\tif (flagMatchError) {\n\t\tthrow new TypeError(\n\t\t\t`regex has unmatched slashes, f.e. r\\`/foo\\` or r\\`foo/\\` instead of r\\`/foo/\\`. Input was: ${result}.`,\n\t\t)\n\t}\n\n\treturn new RegExp(result, flags)\n}\n\nexport const r = regexr\n\n/** helpers */\n\n/**\n * escapes a string literal\n * Adapted from https://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex\n *\n * @param {string} A string to be literally matched (it does not represent a\n * RegExp). For example, \"foo$bar\" will be converted to \"foo\\$bar\" so that the\n * `$` is not treated as a RegExp special character.\n */\n// TODO replace certain characters with escape representations, f.e. line breaks\n// with \\n, tabs with \\t, etc\nexport const escape = (string: string) => string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') // $& means the whole matched string\n\nexport const e = escape\n\nexport const version = '2.0.2'\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","regexr","literals","substitutions","result","flags","rawLiterals","raw","last","length","flagsMatch","match","flagMatchError","replace","i","l","sub","RegExp","source","String","TypeError","r","escape","string","e","version"],"sourceRoot":""}